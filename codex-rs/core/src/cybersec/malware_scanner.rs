//! Malware detection and scanning functionality.

use crate::cybersec::{SecurityThreat, ThreatLevel};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::time::Instant;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareSignature {
    pub id: String,
    pub name: String,
    pub pattern: String,
    pub severity: ThreatLevel,
    pub description: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    pub file_path: PathBuf,
    pub is_infected: bool,
    pub detected_threats: Vec<MalwareSignature>,
    pub scan_duration: std::time::Duration,
    pub file_size: u64,
    pub file_hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanSummary {
    pub total_files: usize,
    pub infected_files: usize,
    pub threats_found: usize,
    pub scan_duration: std::time::Duration,
    pub highest_threat_level: ThreatLevel,
}

pub struct MalwareScanner {
    signatures: Vec<MalwareSignature>,
    quarantine_path: Option<PathBuf>,
    scan_results: Vec<ScanResult>,
}

impl MalwareScanner {
    pub fn new() -> Self {
        Self {
            signatures: Self::load_default_signatures(),
            quarantine_path: None,
            scan_results: Vec::new(),
        }
    }

    pub fn with_quarantine_path<P: AsRef<Path>>(mut self, path: P) -> Self {
        self.quarantine_path = Some(path.as_ref().to_path_buf());
        self
    }

    /// Load default malware signatures for Mac-specific threats targeting crypto/developers
    fn load_default_signatures() -> Vec<MalwareSignature> {
        vec![
            // Mac crypto wallet stealers
            MalwareSignature {
                id: "atomic_stealer".to_string(),
                name: "Atomic Stealer (Mac)".to_string(),
                pattern: r"(~/Library/Application Support/(Electrum|Exodus|MetaMask|Coinbase Wallet)|\.wallet\.dat|keychain\.db)".to_string(),
                severity: ThreatLevel::Critical,
                description: "AtomicStealer malware targeting cryptocurrency wallets and browser data on macOS".to_string(),
            },
            MalwareSignature {
                id: "rustbucket_macos".to_string(),
                name: "RustBucket (macOS)".to_string(),
                pattern: r"(\.app/Contents/MacOS/.*rust|lazarus.*group|fake.*app.*bundle)".to_string(),
                severity: ThreatLevel::Critical,
                description: "RustBucket malware used by Lazarus Group targeting macOS developers".to_string(),
            },
            MalwareSignature {
                id: "kandykorn_macos".to_string(),
                name: "KandyKorn (macOS)".to_string(),
                pattern: r"(kandykorn|Discord.*fake.*update|3CX.*supply.*chain)".to_string(),
                severity: ThreatLevel::Critical,
                description: "KandyKorn macOS malware distributed through fake Discord updates".to_string(),
            },
            MalwareSignature {
                id: "xcsset_macos".to_string(),
                name: "XCSSET (Xcode Hijacker)".to_string(),
                pattern: r"(XCSSET|\.xcodeproj.*malicious|DerivedData.*inject)".to_string(),
                severity: ThreatLevel::High,
                description: "XCSSET malware targeting Xcode developers through infected projects".to_string(),
            },
            MalwareSignature {
                id: "oceanslotus_macos".to_string(),
                name: "OceanLotus (macOS)".to_string(),
                pattern: r"(rotlog|OceanLotus|fake.*adobe.*update|\.app.*bundle.*trojan)".to_string(),
                severity: ThreatLevel::High,
                description: "OceanLotus APT malware targeting macOS with fake Adobe updates".to_string(),
            },
            
            // Mac clipboard hijackers targeting crypto
            MalwareSignature {
                id: "mac_crypto_clipper".to_string(),
                name: "Mac Crypto Clipper".to_string(),
                pattern: r"(NSPasteboard.*crypto|clipboard.*bitcoin|wallet.*address.*replace)".to_string(),
                severity: ThreatLevel::High,
                description: "Cryptocurrency clipboard hijacker for macOS replacing wallet addresses".to_string(),
            },
            
            // Fake crypto apps
            MalwareSignature {
                id: "fake_crypto_app_mac".to_string(),
                name: "Fake Crypto App (Mac)".to_string(),
                pattern: r"(fake.*metamask\.app|bogus.*wallet\.app|trojan.*crypto.*bundle)".to_string(),
                severity: ThreatLevel::High,
                description: "Fake cryptocurrency wallet application bundle for macOS".to_string(),
            },
            
            // Developer-targeted malware
            MalwareSignature {
                id: "npm_package_stealer".to_string(),
                name: "NPM Package Stealer".to_string(),
                pattern: r"(npm.*install.*malicious|node_modules.*stealer|package\.json.*backdoor)".to_string(),
                severity: ThreatLevel::High,
                description: "Malicious NPM package designed to steal developer credentials".to_string(),
            },
            MalwareSignature {
                id: "github_token_stealer".to_string(),
                name: "GitHub Token Stealer".to_string(),
                pattern: r"(gh[ps]_[a-zA-Z0-9]{36}|GITHUB_TOKEN.*steal|\.git.*credentials.*extract)".to_string(),
                severity: ThreatLevel::High,
                description: "Malware attempting to steal GitHub personal access tokens".to_string(),
            },
            MalwareSignature {
                id: "fake_xcode_dmg".to_string(),
                name: "Fake Xcode DMG".to_string(),
                pattern: r"(Xcode.*\.dmg.*trojan|fake.*apple.*developer|malicious.*xcode.*installer)".to_string(),
                severity: ThreatLevel::High,
                description: "Fake Xcode installer containing malware targeting iOS developers".to_string(),
            },
            
            // Mac persistence mechanisms
            MalwareSignature {
                id: "launchagent_persistence".to_string(),
                name: "LaunchAgent Persistence".to_string(),
                pattern: r"(~/Library/LaunchAgents/.*\.plist|/Library/LaunchDaemons/.*malicious)".to_string(),
                severity: ThreatLevel::Medium,
                description: "Malware using macOS LaunchAgent for persistence".to_string(),
            },
            MalwareSignature {
                id: "startup_items_mac".to_string(),
                name: "Startup Items (Mac)".to_string(),
                pattern: r"(/System/Library/StartupItems|/Library/StartupItems.*malicious)".to_string(),
                severity: ThreatLevel::Medium,
                description: "Malware using macOS startup items for persistence".to_string(),
            },
            
            // Crypto mining on Mac
            MalwareSignature {
                id: "mac_crypto_miner".to_string(),
                name: "Mac Crypto Miner".to_string(),
                pattern: r"(xmrig.*macos|monero.*miner.*mac|cpu.*mining.*background|stratum.*pool.*mac)".to_string(),
                severity: ThreatLevel::Medium,
                description: "Cryptocurrency mining software running on macOS".to_string(),
            },
            
            // Browser extension malware
            MalwareSignature {
                id: "malicious_browser_ext".to_string(),
                name: "Malicious Browser Extension".to_string(),
                pattern: r"(chrome.*extension.*steal|safari.*extension.*crypto|browser.*wallet.*hijack)".to_string(),
                severity: ThreatLevel::High,
                description: "Malicious browser extension targeting cryptocurrency wallets".to_string(),
            },
            
            // PDF/Document malware
            MalwareSignature {
                id: "malicious_pdf_mac".to_string(),
                name: "Malicious PDF (Mac)".to_string(),
                pattern: r"(\.pdf.*javascript.*exploit|adobe.*reader.*vulnerability|document.*malware.*mac)".to_string(),
                severity: ThreatLevel::Medium,
                description: "PDF document containing macOS-targeted malware".to_string(),
            },
            
            // Supply chain attacks
            MalwareSignature {
                id: "brew_package_compromise".to_string(),
                name: "Homebrew Package Compromise".to_string(),
                pattern: r"(brew.*install.*malicious|homebrew.*package.*backdoor|/usr/local/bin/.*trojan)".to_string(),
                severity: ThreatLevel::High,
                description: "Compromised Homebrew package containing malware".to_string(),
            },
            
            // Generic patterns for new threats
            MalwareSignature {
                id: "suspicious_network_mac".to_string(),
                name: "Suspicious Network Activity (Mac)".to_string(),
                pattern: r"(nc.*-e.*bash|curl.*pipe.*bash|wget.*execute|python.*-c.*socket)".to_string(),
                severity: ThreatLevel::High,
                description: "Suspicious network activity indicative of remote access trojan".to_string(),
            },
        ]
    }

    /// Add a custom signature
    pub fn add_signature(&mut self, signature: MalwareSignature) {
        self.signatures.push(signature);
    }

    /// Scan a single file for malware
    pub fn scan_file<P: AsRef<Path>>(&mut self, file_path: P) -> Result<ScanResult, Box<dyn std::error::Error>> {
        let start_time = Instant::now();
        let path = file_path.as_ref();
        
        // Read file content (in a real implementation, this would be more sophisticated)
        let content = std::fs::read_to_string(path).unwrap_or_else(|_| {
            // If we can't read as text, try to read as binary and convert to hex
            std::fs::read(path)
                .map(|bytes| hex::encode(bytes))
                .unwrap_or_default()
        });

        let file_size = std::fs::metadata(path)?.len();
        let file_hash = format!("{:x}", md5::compute(&content));

        let mut detected_threats = Vec::new();

        // Check against all signatures
        for signature in &self.signatures {
            if let Ok(regex) = regex::Regex::new(&signature.pattern) {
                if regex.is_match(&content) {
                    detected_threats.push(signature.clone());
                }
            }
        }

        let scan_duration = start_time.elapsed();
        let result = ScanResult {
            file_path: path.to_path_buf(),
            is_infected: !detected_threats.is_empty(),
            detected_threats,
            scan_duration,
            file_size,
            file_hash,
        };

        self.scan_results.push(result.clone());
        Ok(result)
    }

    /// Scan a directory recursively
    pub fn scan_directory<P: AsRef<Path>>(&mut self, dir_path: P) -> Result<ScanSummary, Box<dyn std::error::Error>> {
        let start_time = Instant::now();
        let mut total_files = 0;
        let mut infected_files = 0;
        let mut threats_found = 0;
        let mut highest_threat_level = ThreatLevel::None;

        fn scan_recursive(
            scanner: &mut MalwareScanner,
            path: &Path,
            total_files: &mut usize,
            infected_files: &mut usize,
            threats_found: &mut usize,
            highest_threat_level: &mut ThreatLevel,
        ) -> Result<(), Box<dyn std::error::Error>> {
            if path.is_file() {
                *total_files += 1;
                if let Ok(result) = scanner.scan_file(path) {
                    if result.is_infected {
                        *infected_files += 1;
                        *threats_found += result.detected_threats.len();
                        
                        for threat in &result.detected_threats {
                            if matches!(threat.severity, ThreatLevel::Critical) {
                                *highest_threat_level = ThreatLevel::Critical;
                            } else if matches!(threat.severity, ThreatLevel::High) && !matches!(highest_threat_level, ThreatLevel::Critical) {
                                *highest_threat_level = ThreatLevel::High;
                            } else if matches!(threat.severity, ThreatLevel::Medium) && matches!(highest_threat_level, ThreatLevel::None | ThreatLevel::Low) {
                                *highest_threat_level = ThreatLevel::Medium;
                            } else if matches!(threat.severity, ThreatLevel::Low) && matches!(highest_threat_level, ThreatLevel::None) {
                                *highest_threat_level = ThreatLevel::Low;
                            }
                        }
                    }
                }
            } else if path.is_dir() {
                for entry in std::fs::read_dir(path)? {
                    let entry = entry?;
                    scan_recursive(scanner, &entry.path(), total_files, infected_files, threats_found, highest_threat_level)?;
                }
            }
            Ok(())
        }

        scan_recursive(self, dir_path.as_ref(), &mut total_files, &mut infected_files, &mut threats_found, &mut highest_threat_level)?;

        Ok(ScanSummary {
            total_files,
            infected_files,
            threats_found,
            scan_duration: start_time.elapsed(),
            highest_threat_level,
        })
    }

    /// Get recent scan results
    pub fn get_recent_results(&self, limit: usize) -> Vec<&ScanResult> {
        self.scan_results.iter().rev().take(limit).collect()
    }

    /// Generate security threats from scan results
    pub fn generate_threats(&self) -> Vec<SecurityThreat> {
        let mut threats = Vec::new();

        for result in &self.scan_results {
            if result.is_infected {
                for signature in &result.detected_threats {
                    let mut threat = SecurityThreat::new(
                        format!("Malware: {}", signature.name),
                        format!("Detected {} in file: {}", signature.description, result.file_path.display()),
                        signature.severity.clone(),
                        0.8, // High confidence for signature-based detection
                    );
                    
                    threat.add_affected_resource(result.file_path.to_string_lossy().to_string());
                    threat.add_recommendation("Quarantine the infected file immediately".to_string());
                    threat.add_recommendation("Run a full system scan".to_string());
                    threat.add_recommendation("Check for other instances of this malware".to_string());
                    
                    threats.push(threat);
                }
            }
        }

        threats
    }

    /// Clear scan history
    pub fn clear_results(&mut self) {
        self.scan_results.clear();
    }

    /// Get scan statistics
    pub fn get_statistics(&self) -> HashMap<String, usize> {
        let mut stats = HashMap::new();
        
        let total_scans = self.scan_results.len();
        let infected_files = self.scan_results.iter().filter(|r| r.is_infected).count();
        let clean_files = total_scans - infected_files;
        
        stats.insert("total_scans".to_string(), total_scans);
        stats.insert("infected_files".to_string(), infected_files);
        stats.insert("clean_files".to_string(), clean_files);
        stats.insert("total_threats".to_string(), 
            self.scan_results.iter().map(|r| r.detected_threats.len()).sum());
            
        stats
    }
}

impl Default for MalwareScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_signature_matching() {
        let mut scanner = MalwareScanner::new();
        
        // Create a temporary file with suspicious content
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "powershell -enc ABC123 -nop -w hidden").unwrap();
        
        let result = scanner.scan_file(temp_file.path()).unwrap();
        assert!(result.is_infected);
        assert!(!result.detected_threats.is_empty());
    }

    #[test]
    fn test_clean_file() {
        let mut scanner = MalwareScanner::new();
        
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "Hello, world!").unwrap();
        
        let result = scanner.scan_file(temp_file.path()).unwrap();
        assert!(!result.is_infected);
        assert!(result.detected_threats.is_empty());
    }
}
